/* automatically generated by rust-bindgen 0.59.2 */

pub const AI_CONFIG_GLOB_MEASURE_TIME: &[u8; 18usize] = b"GLOB_MEASURE_TIME\0";
pub const AI_CONFIG_IMPORT_NO_SKELETON_MESHES: &[u8; 26usize] = b"IMPORT_NO_SKELETON_MESHES\0";
pub const AI_CONFIG_PP_SBBC_MAX_BONES: &[u8; 18usize] = b"PP_SBBC_MAX_BONES\0";
pub const AI_SBBC_DEFAULT_MAX_BONES: u32 = 60;
pub const AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE: &[u8; 26usize] = b"PP_CT_MAX_SMOOTHING_ANGLE\0";
pub const AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX: &[u8; 28usize] = b"PP_CT_TEXTURE_CHANNEL_INDEX\0";
pub const AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE: &[u8; 27usize] = b"PP_GSN_MAX_SMOOTHING_ANGLE\0";
pub const AI_CONFIG_IMPORT_MDL_COLORMAP: &[u8; 20usize] = b"IMPORT_MDL_COLORMAP\0";
pub const AI_CONFIG_PP_RRM_EXCLUDE_LIST: &[u8; 20usize] = b"PP_RRM_EXCLUDE_LIST\0";
pub const AI_CONFIG_PP_PTV_KEEP_HIERARCHY: &[u8; 22usize] = b"PP_PTV_KEEP_HIERARCHY\0";
pub const AI_CONFIG_PP_PTV_NORMALIZE: &[u8; 17usize] = b"PP_PTV_NORMALIZE\0";
pub const AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION: &[u8; 31usize] =
    b"PP_PTV_ADD_ROOT_TRANSFORMATION\0";
pub const AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION: &[u8; 27usize] = b"PP_PTV_ROOT_TRANSFORMATION\0";
pub const AI_CONFIG_PP_FD_REMOVE: &[u8; 13usize] = b"PP_FD_REMOVE\0";
pub const AI_CONFIG_PP_FD_CHECKAREA: &[u8; 16usize] = b"PP_FD_CHECKAREA\0";
pub const AI_CONFIG_PP_OG_EXCLUDE_LIST: &[u8; 19usize] = b"PP_OG_EXCLUDE_LIST\0";
pub const AI_CONFIG_PP_SLM_TRIANGLE_LIMIT: &[u8; 22usize] = b"PP_SLM_TRIANGLE_LIMIT\0";
pub const AI_SLM_DEFAULT_MAX_TRIANGLES: u32 = 1000000;
pub const AI_CONFIG_PP_SLM_VERTEX_LIMIT: &[u8; 20usize] = b"PP_SLM_VERTEX_LIMIT\0";
pub const AI_SLM_DEFAULT_MAX_VERTICES: u32 = 1000000;
pub const AI_CONFIG_PP_LBW_MAX_WEIGHTS: &[u8; 19usize] = b"PP_LBW_MAX_WEIGHTS\0";
pub const AI_LMW_MAX_WEIGHTS: u32 = 4;
pub const AI_CONFIG_PP_DB_THRESHOLD: &[u8; 16usize] = b"PP_DB_THRESHOLD\0";
pub const AI_DEBONE_THRESHOLD: f64 = 1.0;
pub const AI_CONFIG_PP_DB_ALL_OR_NONE: &[u8; 18usize] = b"PP_DB_ALL_OR_NONE\0";
pub const AI_CONFIG_PP_ICL_PTCACHE_SIZE: &[u8; 20usize] = b"PP_ICL_PTCACHE_SIZE\0";
pub const AI_CONFIG_PP_RVC_FLAGS: &[u8; 13usize] = b"PP_RVC_FLAGS\0";
pub const AI_CONFIG_PP_SBP_REMOVE: &[u8; 14usize] = b"PP_SBP_REMOVE\0";
pub const AI_CONFIG_PP_FID_ANIM_ACCURACY: &[u8; 21usize] = b"PP_FID_ANIM_ACCURACY\0";
pub const AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS: &[u8; 28usize] = b"PP_FID_IGNORE_TEXTURECOORDS\0";
pub const AI_UVTRAFO_SCALING: u32 = 1;
pub const AI_UVTRAFO_ROTATION: u32 = 2;
pub const AI_UVTRAFO_TRANSLATION: u32 = 4;
pub const AI_UVTRAFO_ALL: u32 = 7;
pub const AI_CONFIG_PP_TUV_EVALUATE: &[u8; 16usize] = b"PP_TUV_EVALUATE\0";
pub const AI_CONFIG_FAVOUR_SPEED: &[u8; 13usize] = b"FAVOUR_SPEED\0";
pub const AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER: &[u8; 32usize] =
    b"IMPORT_SCHEMA_DOCUMENT_PROVIDER\0";
pub const AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS: &[u8; 36usize] =
    b"IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS\0";
pub const AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS: &[u8; 30usize] =
    b"IMPORT_FBX_READ_ALL_MATERIALS\0";
pub const AI_CONFIG_IMPORT_FBX_READ_MATERIALS: &[u8; 26usize] = b"IMPORT_FBX_READ_MATERIALS\0";
pub const AI_CONFIG_IMPORT_FBX_READ_TEXTURES: &[u8; 25usize] = b"IMPORT_FBX_READ_TEXTURES\0";
pub const AI_CONFIG_IMPORT_FBX_READ_CAMERAS: &[u8; 24usize] = b"IMPORT_FBX_READ_CAMERAS\0";
pub const AI_CONFIG_IMPORT_FBX_READ_LIGHTS: &[u8; 23usize] = b"IMPORT_FBX_READ_LIGHTS\0";
pub const AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS: &[u8; 27usize] = b"IMPORT_FBX_READ_ANIMATIONS\0";
pub const AI_CONFIG_IMPORT_FBX_READ_WEIGHTS: &[u8; 24usize] = b"IMPORT_FBX_READ_WEIGHTS\0";
pub const AI_CONFIG_IMPORT_FBX_STRICT_MODE: &[u8; 23usize] = b"IMPORT_FBX_STRICT_MODE\0";
pub const AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS: &[u8; 27usize] = b"IMPORT_FBX_PRESERVE_PIVOTS\0";
pub const AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES: &[u8; 43usize] =
    b"IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES\0";
pub const AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING: &[u8; 53usize] =
    b"AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING\0";
pub const AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES: &[u8; 36usize] =
    b"AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES\0";
pub const AI_CONFIG_FBX_CONVERT_TO_M: &[u8; 27usize] = b"AI_CONFIG_FBX_CONVERT_TO_M\0";
pub const AI_CONFIG_IMPORT_GLOBAL_KEYFRAME: &[u8; 23usize] = b"IMPORT_GLOBAL_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_MD3_KEYFRAME: &[u8; 20usize] = b"IMPORT_MD3_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_MD2_KEYFRAME: &[u8; 20usize] = b"IMPORT_MD2_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_MDL_KEYFRAME: &[u8; 20usize] = b"IMPORT_MDL_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_MDC_KEYFRAME: &[u8; 20usize] = b"IMPORT_MDC_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_SMD_KEYFRAME: &[u8; 20usize] = b"IMPORT_SMD_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_UNREAL_KEYFRAME: &[u8; 23usize] = b"IMPORT_UNREAL_KEYFRAME\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS: &[u8; 31usize] =
    b"IMPORT_MDL_HL1_READ_ANIMATIONS\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS: &[u8; 37usize] =
    b"IMPORT_MDL_HL1_READ_ANIMATION_EVENTS\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS: &[u8; 38usize] =
    b"IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS: &[u8; 41usize] =
    b"IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS: &[u8; 32usize] =
    b"IMPORT_MDL_HL1_READ_ATTACHMENTS\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS: &[u8; 37usize] =
    b"IMPORT_MDL_HL1_READ_BONE_CONTROLLERS\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES: &[u8; 29usize] =
    b"IMPORT_MDL_HL1_READ_HITBOXES\0";
pub const AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO: &[u8; 37usize] =
    b"IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO\0";
pub const AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST: &[u8; 31usize] =
    b"IMPORT_SMD_LOAD_ANIMATION_LIST\0";
pub const AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL: &[u8; 26usize] = b"IMPORT_AC_SEPARATE_BFCULL\0";
pub const AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION: &[u8; 27usize] = b"IMPORT_AC_EVAL_SUBDIVISION\0";
pub const AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS: &[u8; 20usize] = b"UNREAL_HANDLE_FLAGS\0";
pub const AI_CONFIG_IMPORT_TER_MAKE_UVS: &[u8; 20usize] = b"IMPORT_TER_MAKE_UVS\0";
pub const AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS: &[u8; 31usize] =
    b"IMPORT_ASE_RECONSTRUCT_NORMALS\0";
pub const AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART: &[u8; 28usize] = b"IMPORT_MD3_HANDLE_MULTIPART\0";
pub const AI_CONFIG_IMPORT_MD3_SKIN_NAME: &[u8; 21usize] = b"IMPORT_MD3_SKIN_NAME\0";
pub const AI_CONFIG_IMPORT_MD3_LOAD_SHADERS: &[u8; 24usize] = b"IMPORT_MD3_LOAD_SHADERS\0";
pub const AI_CONFIG_IMPORT_MD3_SHADER_SRC: &[u8; 22usize] = b"IMPORT_MD3_SHADER_SRC\0";
pub const AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY: &[u8; 26usize] = b"IMPORT_LWO_ONE_LAYER_ONLY\0";
pub const AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD: &[u8; 28usize] = b"IMPORT_MD5_NO_ANIM_AUTOLOAD\0";
pub const AI_CONFIG_IMPORT_LWS_ANIM_START: &[u8; 22usize] = b"IMPORT_LWS_ANIM_START\0";
pub const AI_CONFIG_IMPORT_LWS_ANIM_END: &[u8; 20usize] = b"IMPORT_LWS_ANIM_END\0";
pub const AI_CONFIG_IMPORT_IRR_ANIM_FPS: &[u8; 20usize] = b"IMPORT_IRR_ANIM_FPS\0";
pub const AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE: &[u8; 26usize] = b"IMPORT_OGRE_MATERIAL_FILE\0";
pub const AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME: &[u8; 38usize] =
    b"IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME\0";
pub const AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT: &[u8; 45usize] =
    b"AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT\0";
pub const AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS: &[u8; 38usize] =
    b"IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS\0";
pub const AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION: &[u8; 32usize] =
    b"IMPORT_IFC_CUSTOM_TRIANGULATION\0";
pub const AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE: &[u8; 27usize] = b"IMPORT_IFC_SMOOTHING_ANGLE\0";
pub const AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE: f64 = 10.0;
pub const AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION: &[u8; 36usize] =
    b"IMPORT_IFC_CYLINDRICAL_TESSELLATION\0";
pub const AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION: u32 = 32;
pub const AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION: &[u8; 35usize] =
    b"IMPORT_COLLADA_IGNORE_UP_DIRECTION\0";
pub const AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES: &[u8; 33usize] =
    b"IMPORT_COLLADA_USE_COLLADA_NAMES\0";
pub const AI_CONFIG_EXPORT_XFILE_64BIT: &[u8; 19usize] = b"EXPORT_XFILE_64BIT\0";
pub const AI_CONFIG_EXPORT_POINT_CLOUDS: &[u8; 20usize] = b"EXPORT_POINT_CLOUDS\0";
pub const AI_CONFIG_EXPORT_BLOB_NAME: &[u8; 17usize] = b"EXPORT_BLOB_NAME\0";
pub const AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY: &[u8; 20usize] = b"GLOBAL_SCALE_FACTOR\0";
pub const AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT: f64 = 1.0;
pub const AI_CONFIG_APP_SCALE_KEY: &[u8; 17usize] = b"APP_SCALE_FACTOR\0";
pub const AI_MATH_PI: f64 = 3.141592653589793;
pub const AI_MATH_TWO_PI: f64 = 6.283185307179586;
pub const AI_MATH_HALF_PI: f64 = 1.5707963267948966;
pub const AI_MATH_PI_F: f64 = 3.1415926538;
pub const AI_MATH_TWO_PI_F: f64 = 6.2831853076;
pub const AI_MATH_HALF_PI_F: f64 = 1.5707963269;
pub const AI_FALSE: u32 = 0;
pub const AI_TRUE: u32 = 1;
pub const AI_EMBEDDED_TEXNAME_PREFIX: &[u8; 2usize] = b"*\0";
pub const AI_MAX_FACE_INDICES: u32 = 32767;
pub const AI_MAX_BONE_WEIGHTS: u32 = 2147483647;
pub const AI_MAX_VERTICES: u32 = 2147483647;
pub const AI_MAX_FACES: u32 = 2147483647;
pub const AI_MAX_NUMBER_OF_COLOR_SETS: u32 = 8;
pub const AI_MAX_NUMBER_OF_TEXTURECOORDS: u32 = 8;
pub const AI_DEFAULT_MATERIAL_NAME: &[u8; 16usize] = b"DefaultMaterial\0";
pub const AI_SCENE_FLAGS_INCOMPLETE: u32 = 1;
pub const AI_SCENE_FLAGS_VALIDATED: u32 = 2;
pub const AI_SCENE_FLAGS_VALIDATION_WARNING: u32 = 4;
pub const AI_SCENE_FLAGS_NON_VERBOSE_FORMAT: u32 = 8;
pub const AI_SCENE_FLAGS_TERRAIN: u32 = 16;
pub const AI_SCENE_FLAGS_ALLOW_SHARED: u32 = 32;
pub type size_t = ::std::os::raw::c_ulong;
pub const aiComponent_aiComponent_NORMALS: aiComponent = 2;
pub const aiComponent_aiComponent_TANGENTS_AND_BITANGENTS: aiComponent = 4;
pub const aiComponent_aiComponent_COLORS: aiComponent = 8;
pub const aiComponent_aiComponent_TEXCOORDS: aiComponent = 16;
pub const aiComponent_aiComponent_BONEWEIGHTS: aiComponent = 32;
pub const aiComponent_aiComponent_ANIMATIONS: aiComponent = 64;
pub const aiComponent_aiComponent_TEXTURES: aiComponent = 128;
pub const aiComponent_aiComponent_LIGHTS: aiComponent = 256;
pub const aiComponent_aiComponent_CAMERAS: aiComponent = 512;
pub const aiComponent_aiComponent_MESHES: aiComponent = 1024;
pub const aiComponent_aiComponent_MATERIALS: aiComponent = 2048;
pub const aiComponent__aiComponent_Force32Bit: aiComponent = 2684354559;
pub type aiComponent = ::std::os::raw::c_uint;
pub type ai_real = f32;
pub type ai_int = ::std::os::raw::c_int;
pub type ai_uint = ::std::os::raw::c_uint;
pub const ai_epsilon: ai_real = 0.0000009999999974752427;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiVector2D {
    pub x: ai_real,
    pub y: ai_real,
}
#[test]
fn bindgen_test_layout_aiVector2D() {
    assert_eq!(
        ::std::mem::size_of::<aiVector2D>(),
        8usize,
        concat!("Size of: ", stringify!(aiVector2D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVector2D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiVector2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector2D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiVector3D {
    pub x: ai_real,
    pub y: ai_real,
    pub z: ai_real,
}
#[test]
fn bindgen_test_layout_aiVector3D() {
    assert_eq!(
        ::std::mem::size_of::<aiVector3D>(),
        12usize,
        concat!("Size of: ", stringify!(aiVector3D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVector3D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiVector3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector3D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector3D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector3D>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector3D),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiColor4D {
    pub r: ai_real,
    pub g: ai_real,
    pub b: ai_real,
    pub a: ai_real,
}
#[test]
fn bindgen_test_layout_aiColor4D() {
    assert_eq!(
        ::std::mem::size_of::<aiColor4D>(),
        16usize,
        concat!("Size of: ", stringify!(aiColor4D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiColor4D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiColor4D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiMatrix3x3 {
    pub a1: ai_real,
    pub a2: ai_real,
    pub a3: ai_real,
    pub b1: ai_real,
    pub b2: ai_real,
    pub b3: ai_real,
    pub c1: ai_real,
    pub c2: ai_real,
    pub c3: ai_real,
}
#[test]
fn bindgen_test_layout_aiMatrix3x3() {
    assert_eq!(
        ::std::mem::size_of::<aiMatrix3x3>(),
        36usize,
        concat!("Size of: ", stringify!(aiMatrix3x3))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMatrix3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(aiMatrix3x3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).a1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(a1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).a2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(a2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).a3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(a3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).b1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(b1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).b2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(b2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).b3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(b3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).c1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(c1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).c2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(c2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix3x3>())).c3 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix3x3),
            "::",
            stringify!(c3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiMatrix4x4 {
    pub a1: ai_real,
    pub a2: ai_real,
    pub a3: ai_real,
    pub a4: ai_real,
    pub b1: ai_real,
    pub b2: ai_real,
    pub b3: ai_real,
    pub b4: ai_real,
    pub c1: ai_real,
    pub c2: ai_real,
    pub c3: ai_real,
    pub c4: ai_real,
    pub d1: ai_real,
    pub d2: ai_real,
    pub d3: ai_real,
    pub d4: ai_real,
}
#[test]
fn bindgen_test_layout_aiMatrix4x4() {
    assert_eq!(
        ::std::mem::size_of::<aiMatrix4x4>(),
        64usize,
        concat!("Size of: ", stringify!(aiMatrix4x4))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMatrix4x4>(),
        4usize,
        concat!("Alignment of ", stringify!(aiMatrix4x4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b4 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c4 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d3 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d4 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiQuaternion {
    pub w: ai_real,
    pub x: ai_real,
    pub y: ai_real,
    pub z: ai_real,
}
#[test]
fn bindgen_test_layout_aiQuaternion() {
    assert_eq!(
        ::std::mem::size_of::<aiQuaternion>(),
        16usize,
        concat!("Size of: ", stringify!(aiQuaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<aiQuaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(aiQuaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).z as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(z)
        )
    );
}
pub type ai_int32 = i32;
pub type ai_uint32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiPlane {
    pub a: ai_real,
    pub b: ai_real,
    pub c: ai_real,
    pub d: ai_real,
}
#[test]
fn bindgen_test_layout_aiPlane() {
    assert_eq!(
        ::std::mem::size_of::<aiPlane>(),
        16usize,
        concat!("Size of: ", stringify!(aiPlane))
    );
    assert_eq!(
        ::std::mem::align_of::<aiPlane>(),
        4usize,
        concat!("Alignment of ", stringify!(aiPlane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiPlane>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiPlane),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiPlane>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiPlane),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiPlane>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiPlane),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiPlane>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiPlane),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiRay {
    pub pos: aiVector3D,
    pub dir: aiVector3D,
}
#[test]
fn bindgen_test_layout_aiRay() {
    assert_eq!(
        ::std::mem::size_of::<aiRay>(),
        24usize,
        concat!("Size of: ", stringify!(aiRay))
    );
    assert_eq!(
        ::std::mem::align_of::<aiRay>(),
        4usize,
        concat!("Alignment of ", stringify!(aiRay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiRay>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiRay),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiRay>())).dir as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiRay),
            "::",
            stringify!(dir)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiColor3D {
    pub r: ai_real,
    pub g: ai_real,
    pub b: ai_real,
}
#[test]
fn bindgen_test_layout_aiColor3D() {
    assert_eq!(
        ::std::mem::size_of::<aiColor3D>(),
        12usize,
        concat!("Size of: ", stringify!(aiColor3D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiColor3D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiColor3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor3D>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor3D),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor3D>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor3D),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor3D>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor3D),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiString {
    pub length: ai_uint32,
    pub data: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_aiString() {
    assert_eq!(
        ::std::mem::size_of::<aiString>(),
        1028usize,
        concat!("Size of: ", stringify!(aiString))
    );
    assert_eq!(
        ::std::mem::align_of::<aiString>(),
        4usize,
        concat!("Alignment of ", stringify!(aiString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiString>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiString),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiString>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiString),
            "::",
            stringify!(data)
        )
    );
}
pub const aiReturn_aiReturn_SUCCESS: aiReturn = 0;
pub const aiReturn_aiReturn_FAILURE: aiReturn = -1;
pub const aiReturn_aiReturn_OUTOFMEMORY: aiReturn = -3;
pub const aiReturn__AI_ENFORCE_ENUM_SIZE: aiReturn = 2147483647;
pub type aiReturn = ::std::os::raw::c_int;
pub const aiOrigin_aiOrigin_SET: aiOrigin = 0;
pub const aiOrigin_aiOrigin_CUR: aiOrigin = 1;
pub const aiOrigin_aiOrigin_END: aiOrigin = 2;
pub const aiOrigin__AI_ORIGIN_ENFORCE_ENUM_SIZE: aiOrigin = 2147483647;
pub type aiOrigin = ::std::os::raw::c_uint;
pub const aiDefaultLogStream_aiDefaultLogStream_FILE: aiDefaultLogStream = 1;
pub const aiDefaultLogStream_aiDefaultLogStream_STDOUT: aiDefaultLogStream = 2;
pub const aiDefaultLogStream_aiDefaultLogStream_STDERR: aiDefaultLogStream = 4;
pub const aiDefaultLogStream_aiDefaultLogStream_DEBUGGER: aiDefaultLogStream = 8;
pub const aiDefaultLogStream__AI_DLS_ENFORCE_ENUM_SIZE: aiDefaultLogStream = 2147483647;
pub type aiDefaultLogStream = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMemoryInfo {
    pub textures: ::std::os::raw::c_uint,
    pub materials: ::std::os::raw::c_uint,
    pub meshes: ::std::os::raw::c_uint,
    pub nodes: ::std::os::raw::c_uint,
    pub animations: ::std::os::raw::c_uint,
    pub cameras: ::std::os::raw::c_uint,
    pub lights: ::std::os::raw::c_uint,
    pub total: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<aiMemoryInfo>(),
        32usize,
        concat!("Size of: ", stringify!(aiMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMemoryInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(aiMemoryInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).textures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).materials as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(materials)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).meshes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(meshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).nodes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).animations as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(animations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).cameras as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(cameras)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).lights as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(lights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMemoryInfo>())).total as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMemoryInfo),
            "::",
            stringify!(total)
        )
    );
}
pub const aiImporterFlags_aiImporterFlags_SupportTextFlavour: aiImporterFlags = 1;
pub const aiImporterFlags_aiImporterFlags_SupportBinaryFlavour: aiImporterFlags = 2;
pub const aiImporterFlags_aiImporterFlags_SupportCompressedFlavour: aiImporterFlags = 4;
pub const aiImporterFlags_aiImporterFlags_LimitedSupport: aiImporterFlags = 8;
pub const aiImporterFlags_aiImporterFlags_Experimental: aiImporterFlags = 16;
pub type aiImporterFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiImporterDesc {
    pub mName: *const ::std::os::raw::c_char,
    pub mAuthor: *const ::std::os::raw::c_char,
    pub mMaintainer: *const ::std::os::raw::c_char,
    pub mComments: *const ::std::os::raw::c_char,
    pub mFlags: ::std::os::raw::c_uint,
    pub mMinMajor: ::std::os::raw::c_uint,
    pub mMinMinor: ::std::os::raw::c_uint,
    pub mMaxMajor: ::std::os::raw::c_uint,
    pub mMaxMinor: ::std::os::raw::c_uint,
    pub mFileExtensions: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiImporterDesc() {
    assert_eq!(
        ::std::mem::size_of::<aiImporterDesc>(),
        64usize,
        concat!("Size of: ", stringify!(aiImporterDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<aiImporterDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(aiImporterDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mAuthor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mAuthor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mMaintainer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mMaintainer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mComments as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mComments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mFlags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mMinMajor as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mMinMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mMinMinor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mMinMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mMaxMajor as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mMaxMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mMaxMinor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mMaxMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiImporterDesc>())).mFileExtensions as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aiImporterDesc),
            "::",
            stringify!(mFileExtensions)
        )
    );
}
extern "C" {
    pub fn aiGetImporterDesc(extension: *const ::std::os::raw::c_char) -> *const aiImporterDesc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiFileIO {
    _unused: [u8; 0],
}
pub type aiLogStreamCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_char),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiLogStream {
    pub callback: aiLogStreamCallback,
    pub user: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiLogStream() {
    assert_eq!(
        ::std::mem::size_of::<aiLogStream>(),
        16usize,
        concat!("Size of: ", stringify!(aiLogStream))
    );
    assert_eq!(
        ::std::mem::align_of::<aiLogStream>(),
        8usize,
        concat!("Alignment of ", stringify!(aiLogStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLogStream>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLogStream),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLogStream>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLogStream),
            "::",
            stringify!(user)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiPropertyStore {
    pub sentinel: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiPropertyStore() {
    assert_eq!(
        ::std::mem::size_of::<aiPropertyStore>(),
        1usize,
        concat!("Size of: ", stringify!(aiPropertyStore))
    );
    assert_eq!(
        ::std::mem::align_of::<aiPropertyStore>(),
        1usize,
        concat!("Alignment of ", stringify!(aiPropertyStore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiPropertyStore>())).sentinel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiPropertyStore),
            "::",
            stringify!(sentinel)
        )
    );
}
pub type aiBool = ::std::os::raw::c_int;
extern "C" {
    pub fn aiImportFile(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
    ) -> *const aiScene;
}
extern "C" {
    pub fn aiImportFileEx(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
        pFS: *mut aiFileIO,
    ) -> *const aiScene;
}
extern "C" {
    pub fn aiImportFileExWithProperties(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
        pFS: *mut aiFileIO,
        pProps: *const aiPropertyStore,
    ) -> *const aiScene;
}
extern "C" {
    pub fn aiImportFileFromMemory(
        pBuffer: *const ::std::os::raw::c_char,
        pLength: ::std::os::raw::c_uint,
        pFlags: ::std::os::raw::c_uint,
        pHint: *const ::std::os::raw::c_char,
    ) -> *const aiScene;
}
extern "C" {
    pub fn aiImportFileFromMemoryWithProperties(
        pBuffer: *const ::std::os::raw::c_char,
        pLength: ::std::os::raw::c_uint,
        pFlags: ::std::os::raw::c_uint,
        pHint: *const ::std::os::raw::c_char,
        pProps: *const aiPropertyStore,
    ) -> *const aiScene;
}
extern "C" {
    pub fn aiApplyPostProcessing(
        pScene: *const aiScene,
        pFlags: ::std::os::raw::c_uint,
    ) -> *const aiScene;
}
extern "C" {
    pub fn aiGetPredefinedLogStream(
        pStreams: aiDefaultLogStream,
        file: *const ::std::os::raw::c_char,
    ) -> aiLogStream;
}
extern "C" {
    pub fn aiAttachLogStream(stream: *const aiLogStream);
}
extern "C" {
    pub fn aiEnableVerboseLogging(d: aiBool);
}
extern "C" {
    pub fn aiDetachLogStream(stream: *const aiLogStream) -> aiReturn;
}
extern "C" {
    pub fn aiDetachAllLogStreams();
}
extern "C" {
    pub fn aiReleaseImport(pScene: *const aiScene);
}
extern "C" {
    pub fn aiGetErrorString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aiIsExtensionSupported(szExtension: *const ::std::os::raw::c_char) -> aiBool;
}
extern "C" {
    pub fn aiGetExtensionList(szOut: *mut aiString);
}
extern "C" {
    pub fn aiGetMemoryRequirements(pIn: *const aiScene, in_: *mut aiMemoryInfo);
}
extern "C" {
    pub fn aiCreatePropertyStore() -> *mut aiPropertyStore;
}
extern "C" {
    pub fn aiReleasePropertyStore(p: *mut aiPropertyStore);
}
extern "C" {
    pub fn aiSetImportPropertyInteger(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aiSetImportPropertyFloat(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        value: ai_real,
    );
}
extern "C" {
    pub fn aiSetImportPropertyString(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        st: *const aiString,
    );
}
extern "C" {
    pub fn aiSetImportPropertyMatrix(
        store: *mut aiPropertyStore,
        szName: *const ::std::os::raw::c_char,
        mat: *const aiMatrix4x4,
    );
}
extern "C" {
    pub fn aiCreateQuaternionFromMatrix(quat: *mut aiQuaternion, mat: *const aiMatrix3x3);
}
extern "C" {
    pub fn aiDecomposeMatrix(
        mat: *const aiMatrix4x4,
        scaling: *mut aiVector3D,
        rotation: *mut aiQuaternion,
        position: *mut aiVector3D,
    );
}
extern "C" {
    pub fn aiTransposeMatrix4(mat: *mut aiMatrix4x4);
}
extern "C" {
    pub fn aiTransposeMatrix3(mat: *mut aiMatrix3x3);
}
extern "C" {
    pub fn aiTransformVecByMatrix3(vec: *mut aiVector3D, mat: *const aiMatrix3x3);
}
extern "C" {
    pub fn aiTransformVecByMatrix4(vec: *mut aiVector3D, mat: *const aiMatrix4x4);
}
extern "C" {
    pub fn aiMultiplyMatrix4(dst: *mut aiMatrix4x4, src: *const aiMatrix4x4);
}
extern "C" {
    pub fn aiMultiplyMatrix3(dst: *mut aiMatrix3x3, src: *const aiMatrix3x3);
}
extern "C" {
    pub fn aiIdentityMatrix3(mat: *mut aiMatrix3x3);
}
extern "C" {
    pub fn aiIdentityMatrix4(mat: *mut aiMatrix4x4);
}
extern "C" {
    pub fn aiGetImportFormatCount() -> size_t;
}
extern "C" {
    pub fn aiGetImportFormatDescription(pIndex: size_t) -> *const aiImporterDesc;
}
extern "C" {
    pub fn aiVector2AreEqual(a: *const aiVector2D, b: *const aiVector2D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiVector2AreEqualEpsilon(
        a: *const aiVector2D,
        b: *const aiVector2D,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiVector2Add(dst: *mut aiVector2D, src: *const aiVector2D);
}
extern "C" {
    pub fn aiVector2Subtract(dst: *mut aiVector2D, src: *const aiVector2D);
}
extern "C" {
    pub fn aiVector2Scale(dst: *mut aiVector2D, s: f32);
}
extern "C" {
    pub fn aiVector2SymMul(dst: *mut aiVector2D, other: *const aiVector2D);
}
extern "C" {
    pub fn aiVector2DivideByScalar(dst: *mut aiVector2D, s: f32);
}
extern "C" {
    pub fn aiVector2DivideByVector(dst: *mut aiVector2D, v: *mut aiVector2D);
}
extern "C" {
    pub fn aiVector2Length(v: *const aiVector2D) -> f32;
}
extern "C" {
    pub fn aiVector2SquareLength(v: *const aiVector2D) -> f32;
}
extern "C" {
    pub fn aiVector2Negate(dst: *mut aiVector2D);
}
extern "C" {
    pub fn aiVector2DotProduct(a: *const aiVector2D, b: *const aiVector2D) -> f32;
}
extern "C" {
    pub fn aiVector2Normalize(v: *mut aiVector2D);
}
extern "C" {
    pub fn aiVector3AreEqual(a: *const aiVector3D, b: *const aiVector3D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiVector3AreEqualEpsilon(
        a: *const aiVector3D,
        b: *const aiVector3D,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiVector3LessThan(a: *const aiVector3D, b: *const aiVector3D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiVector3Add(dst: *mut aiVector3D, src: *const aiVector3D);
}
extern "C" {
    pub fn aiVector3Subtract(dst: *mut aiVector3D, src: *const aiVector3D);
}
extern "C" {
    pub fn aiVector3Scale(dst: *mut aiVector3D, s: f32);
}
extern "C" {
    pub fn aiVector3SymMul(dst: *mut aiVector3D, other: *const aiVector3D);
}
extern "C" {
    pub fn aiVector3DivideByScalar(dst: *mut aiVector3D, s: f32);
}
extern "C" {
    pub fn aiVector3DivideByVector(dst: *mut aiVector3D, v: *mut aiVector3D);
}
extern "C" {
    pub fn aiVector3Length(v: *const aiVector3D) -> f32;
}
extern "C" {
    pub fn aiVector3SquareLength(v: *const aiVector3D) -> f32;
}
extern "C" {
    pub fn aiVector3Negate(dst: *mut aiVector3D);
}
extern "C" {
    pub fn aiVector3DotProduct(a: *const aiVector3D, b: *const aiVector3D) -> f32;
}
extern "C" {
    pub fn aiVector3CrossProduct(dst: *mut aiVector3D, a: *const aiVector3D, b: *const aiVector3D);
}
extern "C" {
    pub fn aiVector3Normalize(v: *mut aiVector3D);
}
extern "C" {
    pub fn aiVector3NormalizeSafe(v: *mut aiVector3D);
}
extern "C" {
    pub fn aiVector3RotateByQuaternion(v: *mut aiVector3D, q: *const aiQuaternion);
}
extern "C" {
    pub fn aiMatrix3FromMatrix4(dst: *mut aiMatrix3x3, mat: *const aiMatrix4x4);
}
extern "C" {
    pub fn aiMatrix3FromQuaternion(mat: *mut aiMatrix3x3, q: *const aiQuaternion);
}
extern "C" {
    pub fn aiMatrix3AreEqual(a: *const aiMatrix3x3, b: *const aiMatrix3x3)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiMatrix3AreEqualEpsilon(
        a: *const aiMatrix3x3,
        b: *const aiMatrix3x3,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiMatrix3Inverse(mat: *mut aiMatrix3x3);
}
extern "C" {
    pub fn aiMatrix3Determinant(mat: *const aiMatrix3x3) -> f32;
}
extern "C" {
    pub fn aiMatrix3RotationZ(mat: *mut aiMatrix3x3, angle: f32);
}
extern "C" {
    pub fn aiMatrix3FromRotationAroundAxis(
        mat: *mut aiMatrix3x3,
        axis: *const aiVector3D,
        angle: f32,
    );
}
extern "C" {
    pub fn aiMatrix3Translation(mat: *mut aiMatrix3x3, translation: *const aiVector2D);
}
extern "C" {
    pub fn aiMatrix3FromTo(mat: *mut aiMatrix3x3, from: *const aiVector3D, to: *const aiVector3D);
}
extern "C" {
    pub fn aiMatrix4FromMatrix3(dst: *mut aiMatrix4x4, mat: *const aiMatrix3x3);
}
extern "C" {
    pub fn aiMatrix4FromScalingQuaternionPosition(
        mat: *mut aiMatrix4x4,
        scaling: *const aiVector3D,
        rotation: *const aiQuaternion,
        position: *const aiVector3D,
    );
}
extern "C" {
    pub fn aiMatrix4Add(dst: *mut aiMatrix4x4, src: *const aiMatrix4x4);
}
extern "C" {
    pub fn aiMatrix4AreEqual(a: *const aiMatrix4x4, b: *const aiMatrix4x4)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiMatrix4AreEqualEpsilon(
        a: *const aiMatrix4x4,
        b: *const aiMatrix4x4,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiMatrix4Inverse(mat: *mut aiMatrix4x4);
}
extern "C" {
    pub fn aiMatrix4Determinant(mat: *const aiMatrix4x4) -> f32;
}
extern "C" {
    pub fn aiMatrix4IsIdentity(mat: *const aiMatrix4x4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
        mat: *const aiMatrix4x4,
        scaling: *mut aiVector3D,
        rotation: *mut aiVector3D,
        position: *mut aiVector3D,
    );
}
extern "C" {
    pub fn aiMatrix4DecomposeIntoScalingAxisAnglePosition(
        mat: *const aiMatrix4x4,
        scaling: *mut aiVector3D,
        axis: *mut aiVector3D,
        angle: *mut ai_real,
        position: *mut aiVector3D,
    );
}
extern "C" {
    pub fn aiMatrix4DecomposeNoScaling(
        mat: *const aiMatrix4x4,
        rotation: *mut aiQuaternion,
        position: *mut aiVector3D,
    );
}
extern "C" {
    pub fn aiMatrix4FromEulerAngles(mat: *mut aiMatrix4x4, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn aiMatrix4RotationX(mat: *mut aiMatrix4x4, angle: f32);
}
extern "C" {
    pub fn aiMatrix4RotationY(mat: *mut aiMatrix4x4, angle: f32);
}
extern "C" {
    pub fn aiMatrix4RotationZ(mat: *mut aiMatrix4x4, angle: f32);
}
extern "C" {
    pub fn aiMatrix4FromRotationAroundAxis(
        mat: *mut aiMatrix4x4,
        axis: *const aiVector3D,
        angle: f32,
    );
}
extern "C" {
    pub fn aiMatrix4Translation(mat: *mut aiMatrix4x4, translation: *const aiVector3D);
}
extern "C" {
    pub fn aiMatrix4Scaling(mat: *mut aiMatrix4x4, scaling: *const aiVector3D);
}
extern "C" {
    pub fn aiMatrix4FromTo(mat: *mut aiMatrix4x4, from: *const aiVector3D, to: *const aiVector3D);
}
extern "C" {
    pub fn aiQuaternionFromEulerAngles(q: *mut aiQuaternion, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn aiQuaternionFromAxisAngle(q: *mut aiQuaternion, axis: *const aiVector3D, angle: f32);
}
extern "C" {
    pub fn aiQuaternionFromNormalizedQuaternion(
        q: *mut aiQuaternion,
        normalized: *const aiVector3D,
    );
}
extern "C" {
    pub fn aiQuaternionAreEqual(
        a: *const aiQuaternion,
        b: *const aiQuaternion,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiQuaternionAreEqualEpsilon(
        a: *const aiQuaternion,
        b: *const aiQuaternion,
        epsilon: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aiQuaternionNormalize(q: *mut aiQuaternion);
}
extern "C" {
    pub fn aiQuaternionConjugate(q: *mut aiQuaternion);
}
extern "C" {
    pub fn aiQuaternionMultiply(dst: *mut aiQuaternion, q: *const aiQuaternion);
}
extern "C" {
    pub fn aiQuaternionInterpolate(
        dst: *mut aiQuaternion,
        start: *const aiQuaternion,
        end: *const aiQuaternion,
        factor: f32,
    );
}
pub const aiPostProcessSteps_aiProcess_CalcTangentSpace: aiPostProcessSteps = 1;
pub const aiPostProcessSteps_aiProcess_JoinIdenticalVertices: aiPostProcessSteps = 2;
pub const aiPostProcessSteps_aiProcess_MakeLeftHanded: aiPostProcessSteps = 4;
pub const aiPostProcessSteps_aiProcess_Triangulate: aiPostProcessSteps = 8;
pub const aiPostProcessSteps_aiProcess_RemoveComponent: aiPostProcessSteps = 16;
pub const aiPostProcessSteps_aiProcess_GenNormals: aiPostProcessSteps = 32;
pub const aiPostProcessSteps_aiProcess_GenSmoothNormals: aiPostProcessSteps = 64;
pub const aiPostProcessSteps_aiProcess_SplitLargeMeshes: aiPostProcessSteps = 128;
pub const aiPostProcessSteps_aiProcess_PreTransformVertices: aiPostProcessSteps = 256;
pub const aiPostProcessSteps_aiProcess_LimitBoneWeights: aiPostProcessSteps = 512;
pub const aiPostProcessSteps_aiProcess_ValidateDataStructure: aiPostProcessSteps = 1024;
pub const aiPostProcessSteps_aiProcess_ImproveCacheLocality: aiPostProcessSteps = 2048;
pub const aiPostProcessSteps_aiProcess_RemoveRedundantMaterials: aiPostProcessSteps = 4096;
pub const aiPostProcessSteps_aiProcess_FixInfacingNormals: aiPostProcessSteps = 8192;
pub const aiPostProcessSteps_aiProcess_PopulateArmatureData: aiPostProcessSteps = 16384;
pub const aiPostProcessSteps_aiProcess_SortByPType: aiPostProcessSteps = 32768;
pub const aiPostProcessSteps_aiProcess_FindDegenerates: aiPostProcessSteps = 65536;
pub const aiPostProcessSteps_aiProcess_FindInvalidData: aiPostProcessSteps = 131072;
pub const aiPostProcessSteps_aiProcess_GenUVCoords: aiPostProcessSteps = 262144;
pub const aiPostProcessSteps_aiProcess_TransformUVCoords: aiPostProcessSteps = 524288;
pub const aiPostProcessSteps_aiProcess_FindInstances: aiPostProcessSteps = 1048576;
pub const aiPostProcessSteps_aiProcess_OptimizeMeshes: aiPostProcessSteps = 2097152;
pub const aiPostProcessSteps_aiProcess_OptimizeGraph: aiPostProcessSteps = 4194304;
pub const aiPostProcessSteps_aiProcess_FlipUVs: aiPostProcessSteps = 8388608;
pub const aiPostProcessSteps_aiProcess_FlipWindingOrder: aiPostProcessSteps = 16777216;
pub const aiPostProcessSteps_aiProcess_SplitByBoneCount: aiPostProcessSteps = 33554432;
pub const aiPostProcessSteps_aiProcess_Debone: aiPostProcessSteps = 67108864;
pub const aiPostProcessSteps_aiProcess_GlobalScale: aiPostProcessSteps = 134217728;
pub const aiPostProcessSteps_aiProcess_EmbedTextures: aiPostProcessSteps = 268435456;
pub const aiPostProcessSteps_aiProcess_ForceGenNormals: aiPostProcessSteps = 536870912;
pub const aiPostProcessSteps_aiProcess_DropNormals: aiPostProcessSteps = 1073741824;
pub const aiPostProcessSteps_aiProcess_GenBoundingBoxes: aiPostProcessSteps = 2147483648;
pub type aiPostProcessSteps = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiTexel {
    pub b: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub r: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_aiTexel() {
    assert_eq!(
        ::std::mem::size_of::<aiTexel>(),
        4usize,
        concat!("Size of: ", stringify!(aiTexel))
    );
    assert_eq!(
        ::std::mem::align_of::<aiTexel>(),
        1usize,
        concat!("Alignment of ", stringify!(aiTexel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).r as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiTexture {
    pub mWidth: ::std::os::raw::c_uint,
    pub mHeight: ::std::os::raw::c_uint,
    pub achFormatHint: [::std::os::raw::c_char; 9usize],
    pub pcData: *mut aiTexel,
    pub mFilename: aiString,
}
#[test]
fn bindgen_test_layout_aiTexture() {
    assert_eq!(
        ::std::mem::size_of::<aiTexture>(),
        1064usize,
        concat!("Size of: ", stringify!(aiTexture))
    );
    assert_eq!(
        ::std::mem::align_of::<aiTexture>(),
        8usize,
        concat!("Alignment of ", stringify!(aiTexture))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).mWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(mWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).mHeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(mHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).achFormatHint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(achFormatHint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).pcData as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(pcData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).mFilename as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(mFilename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiAABB {
    pub mMin: aiVector3D,
    pub mMax: aiVector3D,
}
#[test]
fn bindgen_test_layout_aiAABB() {
    assert_eq!(
        ::std::mem::size_of::<aiAABB>(),
        24usize,
        concat!("Size of: ", stringify!(aiAABB))
    );
    assert_eq!(
        ::std::mem::align_of::<aiAABB>(),
        4usize,
        concat!("Alignment of ", stringify!(aiAABB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAABB>())).mMin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAABB),
            "::",
            stringify!(mMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAABB>())).mMax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAABB),
            "::",
            stringify!(mMax)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiFace {
    pub mNumIndices: ::std::os::raw::c_uint,
    pub mIndices: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiFace() {
    assert_eq!(
        ::std::mem::size_of::<aiFace>(),
        16usize,
        concat!("Size of: ", stringify!(aiFace))
    );
    assert_eq!(
        ::std::mem::align_of::<aiFace>(),
        8usize,
        concat!("Alignment of ", stringify!(aiFace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiFace>())).mNumIndices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiFace),
            "::",
            stringify!(mNumIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiFace>())).mIndices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiFace),
            "::",
            stringify!(mIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiVertexWeight {
    pub mVertexId: ::std::os::raw::c_uint,
    pub mWeight: ai_real,
}
#[test]
fn bindgen_test_layout_aiVertexWeight() {
    assert_eq!(
        ::std::mem::size_of::<aiVertexWeight>(),
        8usize,
        concat!("Size of: ", stringify!(aiVertexWeight))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVertexWeight>(),
        4usize,
        concat!("Alignment of ", stringify!(aiVertexWeight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVertexWeight>())).mVertexId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVertexWeight),
            "::",
            stringify!(mVertexId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVertexWeight>())).mWeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVertexWeight),
            "::",
            stringify!(mWeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiBone {
    pub mName: aiString,
    pub mNumWeights: ::std::os::raw::c_uint,
    pub mArmature: *mut aiNode,
    pub mNode: *mut aiNode,
    pub mWeights: *mut aiVertexWeight,
    pub mOffsetMatrix: aiMatrix4x4,
}
#[test]
fn bindgen_test_layout_aiBone() {
    assert_eq!(
        ::std::mem::size_of::<aiBone>(),
        1120usize,
        concat!("Size of: ", stringify!(aiBone))
    );
    assert_eq!(
        ::std::mem::align_of::<aiBone>(),
        8usize,
        concat!("Alignment of ", stringify!(aiBone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mNumWeights as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mNumWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mArmature as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mArmature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mNode as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mWeights as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mOffsetMatrix as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mOffsetMatrix)
        )
    );
}
pub const aiPrimitiveType_aiPrimitiveType_POINT: aiPrimitiveType = 1;
pub const aiPrimitiveType_aiPrimitiveType_LINE: aiPrimitiveType = 2;
pub const aiPrimitiveType_aiPrimitiveType_TRIANGLE: aiPrimitiveType = 4;
pub const aiPrimitiveType_aiPrimitiveType_POLYGON: aiPrimitiveType = 8;
pub const aiPrimitiveType_aiPrimitiveType_NGONEncodingFlag: aiPrimitiveType = 16;
pub const aiPrimitiveType__aiPrimitiveType_Force32Bit: aiPrimitiveType = 2147483647;
pub type aiPrimitiveType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiAnimMesh {
    pub mName: aiString,
    pub mVertices: *mut aiVector3D,
    pub mNormals: *mut aiVector3D,
    pub mTangents: *mut aiVector3D,
    pub mBitangents: *mut aiVector3D,
    pub mColors: [*mut aiColor4D; 8usize],
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    pub mNumVertices: ::std::os::raw::c_uint,
    pub mWeight: f32,
}
#[test]
fn bindgen_test_layout_aiAnimMesh() {
    assert_eq!(
        ::std::mem::size_of::<aiAnimMesh>(),
        1200usize,
        concat!("Size of: ", stringify!(aiAnimMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<aiAnimMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(aiAnimMesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mVertices as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mNormals as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mNormals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mTangents as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mTangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mBitangents as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mBitangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mColors as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mTextureCoords as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mTextureCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mNumVertices as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mNumVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mWeight as *const _ as usize },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mWeight)
        )
    );
}
pub const aiMorphingMethod_aiMorphingMethod_VERTEX_BLEND: aiMorphingMethod = 1;
pub const aiMorphingMethod_aiMorphingMethod_MORPH_NORMALIZED: aiMorphingMethod = 2;
pub const aiMorphingMethod_aiMorphingMethod_MORPH_RELATIVE: aiMorphingMethod = 3;
pub const aiMorphingMethod__aiMorphingMethod_Force32Bit: aiMorphingMethod = 2147483647;
pub type aiMorphingMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiMesh {
    pub mPrimitiveTypes: ::std::os::raw::c_uint,
    pub mNumVertices: ::std::os::raw::c_uint,
    pub mNumFaces: ::std::os::raw::c_uint,
    pub mVertices: *mut aiVector3D,
    pub mNormals: *mut aiVector3D,
    pub mTangents: *mut aiVector3D,
    pub mBitangents: *mut aiVector3D,
    pub mColors: [*mut aiColor4D; 8usize],
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    pub mNumUVComponents: [::std::os::raw::c_uint; 8usize],
    pub mFaces: *mut aiFace,
    pub mNumBones: ::std::os::raw::c_uint,
    pub mBones: *mut *mut aiBone,
    pub mMaterialIndex: ::std::os::raw::c_uint,
    pub mName: aiString,
    pub mNumAnimMeshes: ::std::os::raw::c_uint,
    pub mAnimMeshes: *mut *mut aiAnimMesh,
    pub mMethod: ::std::os::raw::c_uint,
    pub mAABB: aiAABB,
    pub mTextureCoordsNames: *mut *mut aiString,
}
#[test]
fn bindgen_test_layout_aiMesh() {
    assert_eq!(
        ::std::mem::size_of::<aiMesh>(),
        1320usize,
        concat!("Size of: ", stringify!(aiMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mPrimitiveTypes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mPrimitiveTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumVertices as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumFaces as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mVertices as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNormals as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNormals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mTangents as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mTangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mBitangents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mBitangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mColors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mTextureCoords as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mTextureCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumUVComponents as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumUVComponents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mFaces as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumBones as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumBones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mBones as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mBones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mMaterialIndex as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mMaterialIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mName as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumAnimMeshes as *const _ as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumAnimMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mAnimMeshes as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mAnimMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mMethod as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mMethod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mAABB as *const _ as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mAABB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mTextureCoordsNames as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mTextureCoordsNames)
        )
    );
}
pub const aiLightSourceType_aiLightSource_UNDEFINED: aiLightSourceType = 0;
pub const aiLightSourceType_aiLightSource_DIRECTIONAL: aiLightSourceType = 1;
pub const aiLightSourceType_aiLightSource_POINT: aiLightSourceType = 2;
pub const aiLightSourceType_aiLightSource_SPOT: aiLightSourceType = 3;
pub const aiLightSourceType_aiLightSource_AMBIENT: aiLightSourceType = 4;
pub const aiLightSourceType_aiLightSource_AREA: aiLightSourceType = 5;
pub const aiLightSourceType__aiLightSource_Force32Bit: aiLightSourceType = 2147483647;
pub type aiLightSourceType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiLight {
    pub mName: aiString,
    pub mType: aiLightSourceType,
    pub mPosition: aiVector3D,
    pub mDirection: aiVector3D,
    pub mUp: aiVector3D,
    pub mAttenuationConstant: f32,
    pub mAttenuationLinear: f32,
    pub mAttenuationQuadratic: f32,
    pub mColorDiffuse: aiColor3D,
    pub mColorSpecular: aiColor3D,
    pub mColorAmbient: aiColor3D,
    pub mAngleInnerCone: f32,
    pub mAngleOuterCone: f32,
    pub mSize: aiVector2D,
}
#[test]
fn bindgen_test_layout_aiLight() {
    assert_eq!(
        ::std::mem::size_of::<aiLight>(),
        1132usize,
        concat!("Size of: ", stringify!(aiLight))
    );
    assert_eq!(
        ::std::mem::align_of::<aiLight>(),
        4usize,
        concat!("Alignment of ", stringify!(aiLight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mType as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mPosition as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mDirection as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mDirection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mUp as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAttenuationConstant as *const _ as usize },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAttenuationConstant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAttenuationLinear as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAttenuationLinear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAttenuationQuadratic as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAttenuationQuadratic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mColorDiffuse as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mColorDiffuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mColorSpecular as *const _ as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mColorSpecular)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mColorAmbient as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mColorAmbient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAngleInnerCone as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAngleInnerCone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAngleOuterCone as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAngleOuterCone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mSize as *const _ as usize },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiCamera {
    pub mName: aiString,
    pub mPosition: aiVector3D,
    pub mUp: aiVector3D,
    pub mLookAt: aiVector3D,
    pub mHorizontalFOV: f32,
    pub mClipPlaneNear: f32,
    pub mClipPlaneFar: f32,
    pub mAspect: f32,
    pub mOrthographicWidth: f32,
}
#[test]
fn bindgen_test_layout_aiCamera() {
    assert_eq!(
        ::std::mem::size_of::<aiCamera>(),
        1084usize,
        concat!("Size of: ", stringify!(aiCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<aiCamera>(),
        4usize,
        concat!("Alignment of ", stringify!(aiCamera))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mPosition as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mUp as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mLookAt as *const _ as usize },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mLookAt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mHorizontalFOV as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mHorizontalFOV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mClipPlaneNear as *const _ as usize },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mClipPlaneNear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mClipPlaneFar as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mClipPlaneFar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mAspect as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mAspect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mOrthographicWidth as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mOrthographicWidth)
        )
    );
}
pub const aiTextureOp_aiTextureOp_Multiply: aiTextureOp = 0;
pub const aiTextureOp_aiTextureOp_Add: aiTextureOp = 1;
pub const aiTextureOp_aiTextureOp_Subtract: aiTextureOp = 2;
pub const aiTextureOp_aiTextureOp_Divide: aiTextureOp = 3;
pub const aiTextureOp_aiTextureOp_SmoothAdd: aiTextureOp = 4;
pub const aiTextureOp_aiTextureOp_SignedAdd: aiTextureOp = 5;
pub const aiTextureOp__aiTextureOp_Force32Bit: aiTextureOp = 2147483647;
pub type aiTextureOp = ::std::os::raw::c_uint;
pub const aiTextureMapMode_aiTextureMapMode_Wrap: aiTextureMapMode = 0;
pub const aiTextureMapMode_aiTextureMapMode_Clamp: aiTextureMapMode = 1;
pub const aiTextureMapMode_aiTextureMapMode_Decal: aiTextureMapMode = 3;
pub const aiTextureMapMode_aiTextureMapMode_Mirror: aiTextureMapMode = 2;
pub const aiTextureMapMode__aiTextureMapMode_Force32Bit: aiTextureMapMode = 2147483647;
pub type aiTextureMapMode = ::std::os::raw::c_uint;
pub const aiTextureMapping_aiTextureMapping_UV: aiTextureMapping = 0;
pub const aiTextureMapping_aiTextureMapping_SPHERE: aiTextureMapping = 1;
pub const aiTextureMapping_aiTextureMapping_CYLINDER: aiTextureMapping = 2;
pub const aiTextureMapping_aiTextureMapping_BOX: aiTextureMapping = 3;
pub const aiTextureMapping_aiTextureMapping_PLANE: aiTextureMapping = 4;
pub const aiTextureMapping_aiTextureMapping_OTHER: aiTextureMapping = 5;
pub const aiTextureMapping__aiTextureMapping_Force32Bit: aiTextureMapping = 2147483647;
pub type aiTextureMapping = ::std::os::raw::c_uint;
pub const aiTextureType_aiTextureType_NONE: aiTextureType = 0;
pub const aiTextureType_aiTextureType_DIFFUSE: aiTextureType = 1;
pub const aiTextureType_aiTextureType_SPECULAR: aiTextureType = 2;
pub const aiTextureType_aiTextureType_AMBIENT: aiTextureType = 3;
pub const aiTextureType_aiTextureType_EMISSIVE: aiTextureType = 4;
pub const aiTextureType_aiTextureType_HEIGHT: aiTextureType = 5;
pub const aiTextureType_aiTextureType_NORMALS: aiTextureType = 6;
pub const aiTextureType_aiTextureType_SHININESS: aiTextureType = 7;
pub const aiTextureType_aiTextureType_OPACITY: aiTextureType = 8;
pub const aiTextureType_aiTextureType_DISPLACEMENT: aiTextureType = 9;
pub const aiTextureType_aiTextureType_LIGHTMAP: aiTextureType = 10;
pub const aiTextureType_aiTextureType_REFLECTION: aiTextureType = 11;
pub const aiTextureType_aiTextureType_BASE_COLOR: aiTextureType = 12;
pub const aiTextureType_aiTextureType_NORMAL_CAMERA: aiTextureType = 13;
pub const aiTextureType_aiTextureType_EMISSION_COLOR: aiTextureType = 14;
pub const aiTextureType_aiTextureType_METALNESS: aiTextureType = 15;
pub const aiTextureType_aiTextureType_DIFFUSE_ROUGHNESS: aiTextureType = 16;
pub const aiTextureType_aiTextureType_AMBIENT_OCCLUSION: aiTextureType = 17;
pub const aiTextureType_aiTextureType_SHEEN: aiTextureType = 19;
pub const aiTextureType_aiTextureType_CLEARCOAT: aiTextureType = 20;
pub const aiTextureType_aiTextureType_TRANSMISSION: aiTextureType = 21;
pub const aiTextureType_aiTextureType_UNKNOWN: aiTextureType = 18;
pub const aiTextureType__aiTextureType_Force32Bit: aiTextureType = 2147483647;
pub type aiTextureType = ::std::os::raw::c_uint;
pub const aiShadingMode_aiShadingMode_Flat: aiShadingMode = 1;
pub const aiShadingMode_aiShadingMode_Gouraud: aiShadingMode = 2;
pub const aiShadingMode_aiShadingMode_Phong: aiShadingMode = 3;
pub const aiShadingMode_aiShadingMode_Blinn: aiShadingMode = 4;
pub const aiShadingMode_aiShadingMode_Toon: aiShadingMode = 5;
pub const aiShadingMode_aiShadingMode_OrenNayar: aiShadingMode = 6;
pub const aiShadingMode_aiShadingMode_Minnaert: aiShadingMode = 7;
pub const aiShadingMode_aiShadingMode_CookTorrance: aiShadingMode = 8;
pub const aiShadingMode_aiShadingMode_NoShading: aiShadingMode = 9;
pub const aiShadingMode_aiShadingMode_Unlit: aiShadingMode = 9;
pub const aiShadingMode_aiShadingMode_Fresnel: aiShadingMode = 10;
pub const aiShadingMode_aiShadingMode_PBR_BRDF: aiShadingMode = 11;
pub const aiShadingMode__aiShadingMode_Force32Bit: aiShadingMode = 2147483647;
pub type aiShadingMode = ::std::os::raw::c_uint;
pub const aiTextureFlags_aiTextureFlags_Invert: aiTextureFlags = 1;
pub const aiTextureFlags_aiTextureFlags_UseAlpha: aiTextureFlags = 2;
pub const aiTextureFlags_aiTextureFlags_IgnoreAlpha: aiTextureFlags = 4;
pub const aiTextureFlags__aiTextureFlags_Force32Bit: aiTextureFlags = 2147483647;
pub type aiTextureFlags = ::std::os::raw::c_uint;
pub const aiBlendMode_aiBlendMode_Default: aiBlendMode = 0;
pub const aiBlendMode_aiBlendMode_Additive: aiBlendMode = 1;
pub const aiBlendMode__aiBlendMode_Force32Bit: aiBlendMode = 2147483647;
pub type aiBlendMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiUVTransform {
    pub mTranslation: aiVector2D,
    pub mScaling: aiVector2D,
    pub mRotation: ai_real,
}
#[test]
fn bindgen_test_layout_aiUVTransform() {
    assert_eq!(
        ::std::mem::size_of::<aiUVTransform>(),
        20usize,
        concat!("Size of: ", stringify!(aiUVTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<aiUVTransform>(),
        4usize,
        concat!("Alignment of ", stringify!(aiUVTransform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiUVTransform>())).mTranslation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiUVTransform),
            "::",
            stringify!(mTranslation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiUVTransform>())).mScaling as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiUVTransform),
            "::",
            stringify!(mScaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiUVTransform>())).mRotation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiUVTransform),
            "::",
            stringify!(mRotation)
        )
    );
}
pub const aiPropertyTypeInfo_aiPTI_Float: aiPropertyTypeInfo = 1;
pub const aiPropertyTypeInfo_aiPTI_Double: aiPropertyTypeInfo = 2;
pub const aiPropertyTypeInfo_aiPTI_String: aiPropertyTypeInfo = 3;
pub const aiPropertyTypeInfo_aiPTI_Integer: aiPropertyTypeInfo = 4;
pub const aiPropertyTypeInfo_aiPTI_Buffer: aiPropertyTypeInfo = 5;
pub const aiPropertyTypeInfo__aiPTI_Force32Bit: aiPropertyTypeInfo = 2147483647;
pub type aiPropertyTypeInfo = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMaterialProperty {
    pub mKey: aiString,
    pub mSemantic: ::std::os::raw::c_uint,
    pub mIndex: ::std::os::raw::c_uint,
    pub mDataLength: ::std::os::raw::c_uint,
    pub mType: aiPropertyTypeInfo,
    pub mData: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiMaterialProperty() {
    assert_eq!(
        ::std::mem::size_of::<aiMaterialProperty>(),
        1056usize,
        concat!("Size of: ", stringify!(aiMaterialProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMaterialProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMaterialProperty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mSemantic as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mSemantic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mIndex as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mDataLength as *const _ as usize },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mDataLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mType as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mData as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMaterial {
    pub mProperties: *mut *mut aiMaterialProperty,
    pub mNumProperties: ::std::os::raw::c_uint,
    pub mNumAllocated: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMaterial() {
    assert_eq!(
        ::std::mem::size_of::<aiMaterial>(),
        16usize,
        concat!("Size of: ", stringify!(aiMaterial))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMaterial>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMaterial))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterial>())).mProperties as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterial),
            "::",
            stringify!(mProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterial>())).mNumProperties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterial),
            "::",
            stringify!(mNumProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterial>())).mNumAllocated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterial),
            "::",
            stringify!(mNumAllocated)
        )
    );
}
extern "C" {
    pub fn aiGetMaterialProperty(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pPropOut: *mut *const aiMaterialProperty,
    ) -> aiReturn;
}
extern "C" {
    pub fn aiGetMaterialFloatArray(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut ai_real,
        pMax: *mut ::std::os::raw::c_uint,
    ) -> aiReturn;
}
extern "C" {
    pub fn aiGetMaterialIntegerArray(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut ::std::os::raw::c_int,
        pMax: *mut ::std::os::raw::c_uint,
    ) -> aiReturn;
}
extern "C" {
    pub fn aiGetMaterialColor(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut aiColor4D,
    ) -> aiReturn;
}
extern "C" {
    pub fn aiGetMaterialUVTransform(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut aiUVTransform,
    ) -> aiReturn;
}
extern "C" {
    pub fn aiGetMaterialString(
        pMat: *const aiMaterial,
        pKey: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        pOut: *mut aiString,
    ) -> aiReturn;
}
extern "C" {
    pub fn aiGetMaterialTextureCount(
        pMat: *const aiMaterial,
        type_: aiTextureType,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn aiGetMaterialTexture(
        mat: *const aiMaterial,
        type_: aiTextureType,
        index: ::std::os::raw::c_uint,
        path: *mut aiString,
        mapping: *mut aiTextureMapping,
        uvindex: *mut ::std::os::raw::c_uint,
        blend: *mut ai_real,
        op: *mut aiTextureOp,
        mapmode: *mut aiTextureMapMode,
        flags: *mut ::std::os::raw::c_uint,
    ) -> aiReturn;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiVectorKey {
    pub mTime: f64,
    pub mValue: aiVector3D,
}
#[test]
fn bindgen_test_layout_aiVectorKey() {
    assert_eq!(
        ::std::mem::size_of::<aiVectorKey>(),
        24usize,
        concat!("Size of: ", stringify!(aiVectorKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVectorKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiVectorKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVectorKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVectorKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVectorKey>())).mValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVectorKey),
            "::",
            stringify!(mValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiQuatKey {
    pub mTime: f64,
    pub mValue: aiQuaternion,
}
#[test]
fn bindgen_test_layout_aiQuatKey() {
    assert_eq!(
        ::std::mem::size_of::<aiQuatKey>(),
        24usize,
        concat!("Size of: ", stringify!(aiQuatKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiQuatKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiQuatKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuatKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuatKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuatKey>())).mValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuatKey),
            "::",
            stringify!(mValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiMeshKey {
    pub mTime: f64,
    pub mValue: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMeshKey() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshKey>(),
        16usize,
        concat!("Size of: ", stringify!(aiMeshKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshKey>())).mValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshKey),
            "::",
            stringify!(mValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiMeshMorphKey {
    pub mTime: f64,
    pub mValues: *mut ::std::os::raw::c_uint,
    pub mWeights: *mut f64,
    pub mNumValuesAndWeights: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMeshMorphKey() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshMorphKey>(),
        32usize,
        concat!("Size of: ", stringify!(aiMeshMorphKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshMorphKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshMorphKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphKey>())).mValues as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphKey>())).mWeights as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mWeights)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aiMeshMorphKey>())).mNumValuesAndWeights as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mNumValuesAndWeights)
        )
    );
}
pub const aiAnimBehaviour_aiAnimBehaviour_DEFAULT: aiAnimBehaviour = 0;
pub const aiAnimBehaviour_aiAnimBehaviour_CONSTANT: aiAnimBehaviour = 1;
pub const aiAnimBehaviour_aiAnimBehaviour_LINEAR: aiAnimBehaviour = 2;
pub const aiAnimBehaviour_aiAnimBehaviour_REPEAT: aiAnimBehaviour = 3;
pub const aiAnimBehaviour__aiAnimBehaviour_Force32Bit: aiAnimBehaviour = 2147483647;
pub type aiAnimBehaviour = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiNodeAnim {
    pub mNodeName: aiString,
    pub mNumPositionKeys: ::std::os::raw::c_uint,
    pub mPositionKeys: *mut aiVectorKey,
    pub mNumRotationKeys: ::std::os::raw::c_uint,
    pub mRotationKeys: *mut aiQuatKey,
    pub mNumScalingKeys: ::std::os::raw::c_uint,
    pub mScalingKeys: *mut aiVectorKey,
    pub mPreState: aiAnimBehaviour,
    pub mPostState: aiAnimBehaviour,
}
#[test]
fn bindgen_test_layout_aiNodeAnim() {
    assert_eq!(
        ::std::mem::size_of::<aiNodeAnim>(),
        1080usize,
        concat!("Size of: ", stringify!(aiNodeAnim))
    );
    assert_eq!(
        ::std::mem::align_of::<aiNodeAnim>(),
        8usize,
        concat!("Alignment of ", stringify!(aiNodeAnim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNodeName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNodeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNumPositionKeys as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNumPositionKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mPositionKeys as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mPositionKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNumRotationKeys as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNumRotationKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mRotationKeys as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mRotationKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNumScalingKeys as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNumScalingKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mScalingKeys as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mScalingKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mPreState as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mPreState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mPostState as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mPostState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMeshAnim {
    pub mName: aiString,
    pub mNumKeys: ::std::os::raw::c_uint,
    pub mKeys: *mut aiMeshKey,
}
#[test]
fn bindgen_test_layout_aiMeshAnim() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshAnim>(),
        1040usize,
        concat!("Size of: ", stringify!(aiMeshAnim))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshAnim>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshAnim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshAnim>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshAnim),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshAnim>())).mNumKeys as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshAnim),
            "::",
            stringify!(mNumKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshAnim>())).mKeys as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshAnim),
            "::",
            stringify!(mKeys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMeshMorphAnim {
    pub mName: aiString,
    pub mNumKeys: ::std::os::raw::c_uint,
    pub mKeys: *mut aiMeshMorphKey,
}
#[test]
fn bindgen_test_layout_aiMeshMorphAnim() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshMorphAnim>(),
        1040usize,
        concat!("Size of: ", stringify!(aiMeshMorphAnim))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshMorphAnim>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshMorphAnim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphAnim>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphAnim),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphAnim>())).mNumKeys as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphAnim),
            "::",
            stringify!(mNumKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphAnim>())).mKeys as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphAnim),
            "::",
            stringify!(mKeys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiAnimation {
    pub mName: aiString,
    pub mDuration: f64,
    pub mTicksPerSecond: f64,
    pub mNumChannels: ::std::os::raw::c_uint,
    pub mChannels: *mut *mut aiNodeAnim,
    pub mNumMeshChannels: ::std::os::raw::c_uint,
    pub mMeshChannels: *mut *mut aiMeshAnim,
    pub mNumMorphMeshChannels: ::std::os::raw::c_uint,
    pub mMorphMeshChannels: *mut *mut aiMeshMorphAnim,
}
#[test]
fn bindgen_test_layout_aiAnimation() {
    assert_eq!(
        ::std::mem::size_of::<aiAnimation>(),
        1096usize,
        concat!("Size of: ", stringify!(aiAnimation))
    );
    assert_eq!(
        ::std::mem::align_of::<aiAnimation>(),
        8usize,
        concat!("Alignment of ", stringify!(aiAnimation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mDuration as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mTicksPerSecond as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mTicksPerSecond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mNumChannels as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mNumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mChannels as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mNumMeshChannels as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mNumMeshChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mMeshChannels as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mMeshChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aiAnimation>())).mNumMorphMeshChannels as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mNumMorphMeshChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mMorphMeshChannels as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mMorphMeshChannels)
        )
    );
}
pub const aiMetadataType_AI_BOOL: aiMetadataType = 0;
pub const aiMetadataType_AI_INT32: aiMetadataType = 1;
pub const aiMetadataType_AI_UINT64: aiMetadataType = 2;
pub const aiMetadataType_AI_FLOAT: aiMetadataType = 3;
pub const aiMetadataType_AI_DOUBLE: aiMetadataType = 4;
pub const aiMetadataType_AI_AISTRING: aiMetadataType = 5;
pub const aiMetadataType_AI_AIVECTOR3D: aiMetadataType = 6;
pub const aiMetadataType_AI_AIMETADATA: aiMetadataType = 7;
pub const aiMetadataType_AI_META_MAX: aiMetadataType = 8;
pub const aiMetadataType_FORCE_32BIT: aiMetadataType = 2147483647;
pub type aiMetadataType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMetadataEntry {
    pub mType: aiMetadataType,
    pub mData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aiMetadataEntry() {
    assert_eq!(
        ::std::mem::size_of::<aiMetadataEntry>(),
        16usize,
        concat!("Size of: ", stringify!(aiMetadataEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMetadataEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMetadataEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadataEntry>())).mType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadataEntry),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadataEntry>())).mData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadataEntry),
            "::",
            stringify!(mData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiMetadata {
    pub mNumProperties: ::std::os::raw::c_uint,
    pub mKeys: *mut aiString,
    pub mValues: *mut aiMetadataEntry,
}
#[test]
fn bindgen_test_layout_aiMetadata() {
    assert_eq!(
        ::std::mem::size_of::<aiMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(aiMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadata>())).mNumProperties as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadata),
            "::",
            stringify!(mNumProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadata>())).mKeys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadata),
            "::",
            stringify!(mKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadata>())).mValues as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadata),
            "::",
            stringify!(mValues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct aiNode {
    pub mName: aiString,
    pub mTransformation: aiMatrix4x4,
    pub mParent: *mut aiNode,
    pub mNumChildren: ::std::os::raw::c_uint,
    pub mChildren: *mut *mut aiNode,
    pub mNumMeshes: ::std::os::raw::c_uint,
    pub mMeshes: *mut ::std::os::raw::c_uint,
    pub mMetaData: *mut aiMetadata,
}
#[test]
fn bindgen_test_layout_aiNode() {
    assert_eq!(
        ::std::mem::size_of::<aiNode>(),
        1144usize,
        concat!("Size of: ", stringify!(aiNode))
    );
    assert_eq!(
        ::std::mem::align_of::<aiNode>(),
        8usize,
        concat!("Alignment of ", stringify!(aiNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mTransformation as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mTransformation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mParent as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mParent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mNumChildren as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mNumChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mChildren as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mNumMeshes as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mNumMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mMeshes as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mMetaData as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mMetaData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct aiScene {
    pub mFlags: ::std::os::raw::c_uint,
    pub mRootNode: *mut aiNode,
    pub mNumMeshes: ::std::os::raw::c_uint,
    pub mMeshes: *mut *mut aiMesh,
    pub mNumMaterials: ::std::os::raw::c_uint,
    pub mMaterials: *mut *mut aiMaterial,
    pub mNumAnimations: ::std::os::raw::c_uint,
    pub mAnimations: *mut *mut aiAnimation,
    pub mNumTextures: ::std::os::raw::c_uint,
    pub mTextures: *mut *mut aiTexture,
    pub mNumLights: ::std::os::raw::c_uint,
    pub mLights: *mut *mut aiLight,
    pub mNumCameras: ::std::os::raw::c_uint,
    pub mCameras: *mut *mut aiCamera,
    pub mMetaData: *mut aiMetadata,
    pub mName: aiString,
    pub mPrivate: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiScene() {
    assert_eq!(
        ::std::mem::size_of::<aiScene>(),
        1160usize,
        concat!("Size of: ", stringify!(aiScene))
    );
    assert_eq!(
        ::std::mem::align_of::<aiScene>(),
        8usize,
        concat!("Alignment of ", stringify!(aiScene))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mRootNode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mRootNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumMeshes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mMeshes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumMaterials as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumMaterials)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mMaterials as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mMaterials)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumAnimations as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumAnimations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mAnimations as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mAnimations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumTextures as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumTextures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mTextures as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mTextures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumLights as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumLights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mLights as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mLights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumCameras as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumCameras)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mCameras as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mCameras)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mMetaData as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mMetaData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mName as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mPrivate as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mPrivate)
        )
    );
}
